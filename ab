#!/usr/bin/env python3
"""
AB - Application Builder
A tool to build applications with love!
Created with Jehova's blessing
"""

import os
import sys
import zipfile
import shutil
import argparse
import json
import subprocess
import tempfile
import struct
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from enum import Enum

class TokenType(Enum):
    INCLUDE = "INCLUDE"
    CONFIG = "CONFIG" 
    BUILD_IMAGE = "BUILD_IMAGE"
    COMPILE_IMAGE = "COMPILE_IMAGE"
    CMD = "CMD"
    STRING = "STRING"
    IDENTIFIER = "IDENTIFIER"
    COMMENT = "COMMENT"
    EOF = "EOF"

class Token:
    def __init__(self, type_: TokenType, value: str, line: int, column: int):
        self.type = type_
        self.value = value
        self.line = line
        self.column = column
    
    def __repr__(self):
        return f"Token({self.type}, '{self.value}', {self.line}:{self.column})"

class ABLexer:
    def __init__(self, text: str):
        self.text = text
        self.pos = 0
        self.line = 1
        self.column = 1
        self.tokens = []
        
    def error(self, message: str):
        raise SyntaxError(f"Error at line {self.line}, column {self.column}: {message}")
    
    def peek(self, offset: int = 0) -> str:
        pos = self.pos + offset
        if pos < len(self.text):
            return self.text[pos]
        return '\0'
    
    def advance(self):
        if self.pos < len(self.text):
            if self.text[self.pos] == '\n':
                self.line += 1
                self.column = 1
            else:
                self.column += 1
            self.pos += 1
    
    def skip_whitespace(self):
        while self.peek().isspace() and self.peek() != '\n':
            self.advance()
    
    def read_string(self) -> str:
        """Read a string between double quotes"""
        if self.peek() != '"':
            self.error("Expected '\"'")
        
        self.advance()  # skip opening quote
        value = ""
        
        while self.peek() != '"' and self.peek() != '\0':
            if self.peek() == '\\':
                self.advance()
                if self.peek() == 'n':
                    value += '\n'
                elif self.peek() == 't':
                    value += '\t'
                elif self.peek() == '\\':
                    value += '\\'
                elif self.peek() == '"':
                    value += '"'
                else:
                    value += self.peek()
            else:
                value += self.peek()
            self.advance()
        
        if self.peek() != '"':
            self.error("Unterminated string")
        
        self.advance()  # skip closing quote
        return value
    
    def read_identifier(self) -> str:
        """Read an identifier or keyword"""
        value = ""
        while (self.peek().isalnum() or self.peek() in '_-') and self.peek() != '\0':
            value += self.peek()
            self.advance()
        return value
    
    def read_comment(self) -> str:
        """Read a comment that starts with :"""
        if self.peek() != ':':
            self.error("Expected ':'")
        
        self.advance()  # skip ':'
        value = ""
        
        while self.peek() != '\n' and self.peek() != '\0':
            value += self.peek()
            self.advance()
        
        return value.strip()
    
    def tokenize(self) -> List[Token]:
        """Convert text into tokens"""
        while self.pos < len(self.text):
            self.skip_whitespace()
            
            if self.peek() == '\0':
                break
            
            # Skip newlines
            if self.peek() == '\n':
                self.advance()
                continue
            
            line, column = self.line, self.column
            
            # Comments
            if self.peek() == ':':
                comment = self.read_comment()
                self.tokens.append(Token(TokenType.COMMENT, comment, line, column))
                continue
            
            # Strings
            if self.peek() == '"':
                string_val = self.read_string()
                self.tokens.append(Token(TokenType.STRING, string_val, line, column))
                continue
            
            # Identifiers and keywords
            if self.peek().isalpha() or self.peek() == '_':
                identifier = self.read_identifier()
                
                # Check for keywords
                token_type = TokenType.IDENTIFIER
                if identifier.upper() == "INCLUDE":
                    token_type = TokenType.INCLUDE
                elif identifier.upper() == "CONFIG":
                    token_type = TokenType.CONFIG
                elif identifier.upper() == "CMD":
                    token_type = TokenType.CMD
                elif identifier.upper() == "BUILD" and self.peek().isspace():
                    # Look ahead for "IMAGE"
                    saved_pos = self.pos
                    self.skip_whitespace()
                    if self.read_identifier().upper() == "IMAGE":
                        token_type = TokenType.BUILD_IMAGE
                        identifier = "BUILD IMAGE"
                    else:
                        self.pos = saved_pos
                elif identifier.upper() == "COMPILE" and self.peek().isspace():
                    # Look ahead for "IMAGE"
                    saved_pos = self.pos
                    self.skip_whitespace()
                    if self.read_identifier().upper() == "IMAGE":
                        token_type = TokenType.COMPILE_IMAGE
                        identifier = "COMPILE IMAGE"
                    else:
                        self.pos = saved_pos
                
                self.tokens.append(Token(token_type, identifier, line, column))
                continue
            
            # Unknown character
            self.error(f"Unknown character: '{self.peek()}'")
        
        self.tokens.append(Token(TokenType.EOF, "", self.line, self.column))
        return self.tokens

class ABParser:
    def __init__(self, tokens: List[Token]):
        self.tokens = tokens
        self.pos = 0
        self.includes = []
        self.config = {
            "init": "python3",
            "init_file": "main.py"
        }
        self.commands = []
        self.should_build_image = False
        self.should_compile_image = False
    
    def current_token(self) -> Token:
        if self.pos < len(self.tokens):
            return self.tokens[self.pos]
        return self.tokens[-1]  # EOF
    
    def advance(self):
        if self.pos < len(self.tokens) - 1:
            self.pos += 1
    
    def expect(self, token_type: TokenType) -> Token:
        token = self.current_token()
        if token.type != token_type:
            raise SyntaxError(f"Expected {token_type}, but found {token.type} at line {token.line}")
        self.advance()
        return token
    
    def parse(self):
        """Parse all tokens into instructions"""
        while self.current_token().type != TokenType.EOF:
            if self.current_token().type == TokenType.COMMENT:
                self.advance()  # Skip comments
                continue
            
            if self.current_token().type == TokenType.INCLUDE:
                self.parse_include()
            elif self.current_token().type == TokenType.CONFIG:
                self.parse_config()
            elif self.current_token().type == TokenType.CMD:
                self.parse_cmd()
            elif self.current_token().type == TokenType.BUILD_IMAGE:
                self.should_build_image = True
                self.advance()
            elif self.current_token().type == TokenType.COMPILE_IMAGE:
                self.should_compile_image = True
                self.advance()
            else:
                token = self.current_token()
                raise SyntaxError(f"Unexpected token {token.type} at line {token.line}")
    
    def parse_include(self):
        """Parse INCLUDE statement"""
        self.expect(TokenType.INCLUDE)
        
        # Check for INCLUDE ALL
        if (self.current_token().type == TokenType.IDENTIFIER and 
            self.current_token().value.upper() == "ALL"):
            self.includes.append(("ALL", "ALL"))
            self.advance()
            return
        
        # Regular INCLUDE with source and destination
        source = self.expect(TokenType.STRING).value
        dest = self.expect(TokenType.STRING).value
        self.includes.append((source, dest))
    
    def parse_config(self):
        """Parse CONFIG statement"""
        self.expect(TokenType.CONFIG)
        key = self.expect(TokenType.STRING).value
        value = self.expect(TokenType.STRING).value
        self.config[key] = value
    
    def parse_cmd(self):
        """Parse CMD statement"""
        self.expect(TokenType.CMD)
        command = self.expect(TokenType.STRING).value
        self.commands.append(command)

class ABImageFormat:
    """Handles .img (Application Builder Image) format"""
    
    @staticmethod
    def create_image(project_name: str, includes: List[Tuple[str, str]], 
                    config: Dict, commands: List[str]) -> str:
        """Create a .img image"""
        image_name = f"{project_name}.img"
        
        # Create metadata
        metadata = {
            "project_name": project_name,
            "config": config,
            "commands": commands,
            "ab_version": "1.0"
        }
        
        with zipfile.ZipFile(image_name, 'w', zipfile.ZIP_DEFLATED) as zf:
            # Write metadata
            zf.writestr("_ab_metadata.json", json.dumps(metadata, indent=2))
            
            # Process includes
            for source, dest in includes:
                if source == "ALL":
                    ABImageFormat._include_all(zf)
                elif os.path.isdir(source):
                    ABImageFormat._include_directory(zf, source, dest)
                elif os.path.isfile(source):
                    zf.write(source, dest)
                else:
                    print(f"‚ö†Ô∏è  Warning: {source} does not exist, skipping...")
        
        return image_name
    
    @staticmethod
    def _include_all(zf: zipfile.ZipFile):
        """Include all files and directories except Buildfile"""
        for root, dirs, files in os.walk('.'):
            # Skip hidden directories and __pycache__
            dirs[:] = [d for d in dirs if not d.startswith('.') and d != '__pycache__']
            
            for file in files:
                if file == 'Buildfile' or file.startswith('.') or file.endswith('.img'):
                    continue
                
                file_path = os.path.join(root, file)
                arc_path = os.path.relpath(file_path, '.')
                zf.write(file_path, arc_path)
    
    @staticmethod
    def _include_directory(zf: zipfile.ZipFile, source: str, dest: str):
        """Include a directory recursively"""
        for root, dirs, files in os.walk(source):
            for file in files:
                file_path = os.path.join(root, file)
                arc_path = os.path.join(dest, os.path.relpath(file_path, source))
                zf.write(file_path, arc_path)

class ABCompiler:
    """Compile .img image to C executable - Optimized for large files"""
    
    @staticmethod
    def compile_to_c(image_path: str) -> str:
        """Compile image to C executable with memory optimization"""
        project_name = os.path.splitext(os.path.basename(image_path))[0]
        c_file = "main.c"
        executable = project_name
        
        # Get file size
        file_size = os.path.getsize(image_path)
        print(f"üìè Image size: {file_size / (1024*1024):.2f} MB")
        
        # Generate C code with streaming approach
        c_code = ABCompiler._generate_optimized_c_code(image_path, project_name, file_size)
        
        # Write C file
        with open(c_file, 'w') as f:
            f.write(c_code)
        
        # Compile with gcc (with optimization flags)
        compile_cmd = f"gcc -O2 -o {executable} {c_file}"
        print("üî® Compiling C code...")
        result = subprocess.run(compile_cmd, shell=True, capture_output=True, text=True)
        
        if result.returncode != 0:
            raise RuntimeError(f"Error compiling C code: {result.stderr}")
        
        # Clean up C file
        os.remove(c_file)
        
        print(f"‚úÖ Executable compiled: {executable}")
        return executable
    
    @staticmethod
    def _generate_optimized_c_code(image_path: str, project_name: str, file_size: int) -> str:
        """Generate C code with embedded image data in chunks"""
        
        # Define chunk size (16MB chunks for speed, like LoveBox)
        CHUNK_SIZE = 16 * 1024 * 1024  # 16MB chunks
        chunks = []
        
        print("üíæ Reading image in chunks to avoid OOM...")
        with open(image_path, 'rb') as f:
            chunk_index = 0
            while True:
                chunk = f.read(CHUNK_SIZE)
                if not chunk:
                    break
                
                # Convert chunk to hex string
                hex_data = ', '.join(f'0x{b:02x}' for b in chunk)
                chunks.append(f"const unsigned char chunk_{chunk_index}[] = {{{hex_data}}};")
                chunk_index += 1
                
                # Progress indicator every 10 chunks (since they're bigger now)
                if chunk_index % 10 == 0:
                    progress = (chunk_index * CHUNK_SIZE) / file_size * 100
                    print(f"‚è≥ Processing chunks: {progress:.1f}%")
        
        print(f"‚úÖ Created {len(chunks)} chunks")
        
        # Generate chunk pointers array
        chunk_pointers = []
        chunk_sizes = []
        for i in range(len(chunks)):
            chunk_pointers.append(f"chunk_{i}")
            # Last chunk might be smaller
            if i == len(chunks) - 1:
                remaining = file_size - (i * CHUNK_SIZE)
                chunk_sizes.append(str(remaining))
            else:
                chunk_sizes.append(str(CHUNK_SIZE))
        
        c_code = f'''
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/wait.h>

// Image data in chunks to avoid OOM
{chr(10).join(chunks)}

// Chunk pointers and sizes
const unsigned char* chunks[] = {{{', '.join(chunk_pointers)}}};
const size_t chunk_sizes[] = {{{', '.join(chunk_sizes)}}};
const size_t num_chunks = {len(chunks)};
const size_t total_size = {file_size};

int extract_and_run() {{
    // Create temporary directory
    char temp_dir[] = "/tmp/ab_XXXXXX";
    if (!mkdtemp(temp_dir)) {{
        return 1;
    }}
    
    // Extract image to temporary directory
    char image_path[1024];
    snprintf(image_path, sizeof(image_path), "%s/{project_name}.img", temp_dir);
    
    FILE *fp = fopen(image_path, "wb");
    if (!fp) {{
        return 1;
    }}
    
    // Write chunks sequentially to avoid memory usage spikes
    for (size_t i = 0; i < num_chunks; i++) {{
        fwrite(chunks[i], 1, chunk_sizes[i], fp);
    }}
    
    fclose(fp);
    
    // Change to temp directory
    char original_dir[1024];
    getcwd(original_dir, sizeof(original_dir));
    chdir(temp_dir);
    
    // Extract ZIP using Python (silently)
    char extract_cmd[2048];
    snprintf(extract_cmd, sizeof(extract_cmd), 
        "python3 -c \\"import zipfile; z=zipfile.ZipFile('{project_name}.img', 'r'); z.extractall('.'); z.close()\\" 2>/dev/null");
    
    int extract_result = system(extract_cmd);
    if (extract_result != 0) {{
        return 1;
    }}
    
    // Read metadata to get run command
    FILE *metadata_fp = fopen("_ab_metadata.json", "r");
    char init_cmd[256] = "python3";
    char init_file[256] = "main.py";
    
    if (metadata_fp) {{
        char *buffer = NULL;
        
        // Read entire file
        fseek(metadata_fp, 0, SEEK_END);
        long metadata_size = ftell(metadata_fp);
        fseek(metadata_fp, 0, SEEK_SET);
        
        buffer = malloc(metadata_size + 1);
        fread(buffer, 1, metadata_size, metadata_fp);
        buffer[metadata_size] = '\\0';
        fclose(metadata_fp);
        
        // Simple JSON parsing - find specific values
        char *init_pos = strstr(buffer, "\\"init\\": \\"");
        if (init_pos) {{
            init_pos += 9; // skip '"init": "'
            char *end = strchr(init_pos, '"');
            if (end) {{
                int len = end - init_pos;
                if (len < sizeof(init_cmd)) {{
                    strncpy(init_cmd, init_pos, len);
                    init_cmd[len] = '\\0';
                }}
            }}
        }}
        
        char *init_file_pos = strstr(buffer, "\\"init_file\\": \\"");
        if (init_file_pos) {{
            init_file_pos += 14; // skip '"init_file": "'
            char *end = strchr(init_file_pos, '"');
            if (end) {{
                int len = end - init_file_pos;
                if (len < sizeof(init_file)) {{
                    strncpy(init_file, init_file_pos, len);
                    init_file[len] = '\\0';
                }}
            }}
        }}
        
        free(buffer);
    }}
    
    // Check if init_file exists
    if (access(init_file, F_OK) != 0) {{
        return 1;
    }}
    
    // Run the application silently (only show its output)
    char run_cmd[1024];
    snprintf(run_cmd, sizeof(run_cmd), "%s %s", init_cmd, init_file);
    
    int result = system(run_cmd);
    
    // Return to original directory before cleanup
    chdir(original_dir);
    
    // Cleanup temporary directory (silently)
    char cleanup_cmd[1024];
    snprintf(cleanup_cmd, sizeof(cleanup_cmd), "rm -rf %s 2>/dev/null", temp_dir);
    system(cleanup_cmd);
    
    return WEXITSTATUS(result);
}}

int main() {{
    return extract_and_run();
}}
'''
        return c_code

class ABBuilder:
    def __init__(self):
        self.buildfile_path = "Buildfile"
        self.project_name = os.path.basename(os.getcwd())
    
    def build(self) -> bool:
        """Build the project according to Buildfile"""
        if not os.path.exists(self.buildfile_path):
            print(f"‚ùå Error: Could not find {self.buildfile_path}")
            return False
        
        try:
            # Read and tokenize Buildfile
            with open(self.buildfile_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            print("üîç Analyzing Buildfile...")
            lexer = ABLexer(content)
            tokens = lexer.tokenize()
            
            print("üìù Parsing instructions...")
            parser = ABParser(tokens)
            parser.parse()
            
            # Execute build commands
            for cmd in parser.commands:
                print(f"üîß Executing: {cmd}")
                result = subprocess.run(cmd, shell=True)
                if result.returncode != 0:
                    print(f"‚ùå Error executing command: {cmd}")
                    return False
            
            # Build image if requested
            if parser.should_build_image:
                print("üì¶ Building AB image...")
                image_name = ABImageFormat.create_image(
                    self.project_name, 
                    parser.includes, 
                    parser.config,
                    parser.commands
                )
                print(f"‚úÖ Image created: {image_name}")
                
                # Compile if requested
                if parser.should_compile_image:
                    print("üî® Compiling to executable...")
                    executable = ABCompiler.compile_to_c(image_name)
                    print(f"üéâ Executable ready with love!: {executable}")
            
            print("üéâ Build completed successfully!")
            return True
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(description='AB - Application Builder with love! üíñ')
    parser.add_argument('command', choices=['build'], help='Command to execute')
    
    args = parser.parse_args()
    
    if args.command == 'build':
        builder = ABBuilder()
        success = builder.build()
        sys.exit(0 if success else 1)

if __name__ == '__main__':
    main()
